require "./game.cr"
require "socket"


class Peer < Game

    # Randomly chosen, idk how to choose a port.
    @@lan_notify_port = 17322
    @@connection_port = 34675

    # string sent to notify that there is a new game
    @@notify_string = "new game created!!"

    def initialize(@window)
        super
        # sockets to send info to
        @out_socks = [] of UDPSocket
        # socket to recieve info from
        @in_sock   = UDPSocket.new
        # the port that the peer will listen on
        @port = 0
        # the players local to this game, excludes players sent from other games.
        @local_players = [] of Player
        # make local players so that key input can go only to them
        @local_players += @players
        # make other players accessable by the ip that instatiated them
        @other_players = {} of Socket::IPAddress => Player
        # initialize the network connections and then join the 'swarm', i.e.
        # listen for input so that the game syncs with others.
        init_network()
        spawn join_swarm()
    end

    def init_network
        say "broadcasting..."

        broadcast = UDPSocket.new
        broadcast.broadcast = true
        broadcast.connect "255.255.255.255", @@lan_notify_port

        @in_sock.bind broadcast.local_address.address, @@connection_port

        broadcast.send(@@notify_string)

        spawn listen_for_new_games
    end

    def listen_for_new_games
        listener = UDPSocket.new
        listener.bind "0.0.0.0", @@lan_notify_port
        loop do
            message, sender = listener.receive
            if message == @@notify_string
                process_packet("joining","",sender)
                @out_socks[-1] << "joining<=>lol, pointless text"
            end
        end
    end
    # continuosly take input from peers and process it
    def join_swarm
        say "joining swarm."
        loop do
            message, sender = @in_sock.receive
            subject, body = message.split "<=>"
            process_packet(subject, body, sender)
        end
    end

    # applies a key input to local_players, not players, and sends the
    # input to peers
    def key_input(key, down)
        @local_players.each do |player|
            player.input(key, down)
        end
        str = "in<=>"+key.to_s+","+ (down ? "1" : "0")
        send str
    end

    def tick
      super
      # send all the local player's location to all peers for syncing
      @local_players.each_with_index do |player,i|
          send "up<=>" + i.to_s + "," + player.x.to_s  + "," + player.y.to_s + ","
      end
    end

    # takes in a semi-processed string from join_swarm and does the specified action
    def process_packet(subject, body, sender)
        case subject
        # adds a new peer to the in_socks array and sends them
        # the local players for syncing
        when "joining"
            say "aware of new peer, adding..."
            sock = UDPSocket.new
            sock.connect sender.address, @@connection_port
            @out_socks << sock
            sock << get_player_string
            say "done adding."
        # takes the given input and passes it to the ip's player
        when "in"
            code, d = body.split(",")
            player  = @other_players[sender]
            down    = d[0].to_i == 1
            player.input(code, down)
        # update position of the player
        # IDEA: prevent cheating by stopping the game from moving the player
        # too far.
        when "up"
            ind, x, y = body.split(",")
            player = @other_players[sender]
            player.x = x.to_f
            player.y = y.to_f
        # construct the player from a player string generated by the
        # get_player_string method.
        when "player"
            say "adding player..."
            player = Player.from_string(body, self)
            @players << player
            # assign the new player to the sender's ip
            @other_players[sender] = player
        end
    end

    # sends a string to all the out_socks,
    # if the sending fails it drops the sock from the list
    # the string is received by the process_packet method
    def send(str)
        @out_socks = @out_socks.select do |sock|
            error = false
            begin
              sock << str
            rescue
              error = true
            end
            !error
        end
    end

    # returns a string that when sent to another peer will
    # allow them to construct a clone of the local player.
    # TODO: send all players so that multiple people can play from one computer
    def get_player_string
        player = @local_players[0]
        "player<=>" + player.get_string
    end

    # for printing debug messages
    def say(x)
        puts "PEER: " + x
    end
end
