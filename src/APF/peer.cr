require "./game.cr"
require "socket"


class Peer < Game
    def initialize(@window)
        super
        # sockets to send info to
        @out_socks = [] of UDPSocket
        # socket to recieve info from
        @in_sock   = UDPSocket.new
        # the port that the peer will listen on
        @port = 0
        # the players local to this game, excludes players sent from other games.
        @local_players = [] of Player
        # make local players so that key input can go only to them
        @local_players += @players
        # make other players accessable by the ip that instatiated them
        @other_players = {} of Socket::IPAddress => Player
        # initialize the network connections and then join the 'swarm', i.e.
        # listen for input so that the game syncs with others.
        init_network()
        spawn join_swarm()
    end

    # finds all peers and adds them to in_socks while
    # alerting them of its existence
    def init_network
        say "initializing connections..."
        bound = false
        x = 10000
        port = x
        100.times do
            sock = UDPSocket.new
            begin
                sock.bind "localhost", x
                if bound
                    sock.close
                else
                    @in_sock = sock
                    @port = x
                    bound = true
                end
            rescue
                sock.connect "localhost", x
                @out_socks << sock
            end
            x += 1
        end
        say "done. found "+@out_socks.size.to_s+" other peer(s)"
        say "alerting them..."
        # request joining and then send them the player
        send "joining<=>"+@port.to_s+"\n"
        send get_player_string
        say "done alerting."
    end

    # continuosly take input from peers and process it
    def join_swarm
        say "joining swarm."
        loop do
            message, sender = @in_sock.receive
            subject, body = message.split "<=>"
            process_packet(subject, body, sender)
        end
    end

    # applies a key input to local_players, not players, and sends the
    # input to peers
    def key_input(key, down)
        @local_players.each do |player|
            player.input(key, down)
        end
        str = "in<=>"+key.to_s+","+ (down ? "1" : "0")
        send str
    end

    def tick
      super
      # send all the local player's location to all peers for syncing
      @local_players.each_with_index do |player,i|
          send "up<=>" + i.to_s + "," + player.x.to_s  + "," + player.y.to_s + ","
      end
    end

    # takes in a semi-processed string from join_swarm and does the specified action
    def process_packet(subject, body, sender)
        case subject
        # adds a new peer to the in_socks array and sends them
        # the local players for syncing
        when "joining"
            say "aware of new peer, adding..."
            sock = UDPSocket.new
            sock.connect "localhost", body.to_i
            @out_socks << sock
            sock << get_player_string
            say "done adding."
        # takes the given input and passes it to the ip's player
        when "in"
            code, d = body.split(",")
            player  = @other_players[sender]
            down    = d[0].to_i == 1
            player.input(code, down)
        # update position of the player
        # IDEA: prevent cheating by stopping the game from moving the player
        # too far.
        when "up"
            ind, x, y = body.split(",")
            player = @other_players[sender]
            player.x = x.to_f
            player.y = y.to_f
        # construct the player from a player string generated by the
        # get_player_string method.
        when "player"
            say "adding player..."
            player = Player.from_string(body, self)
            @players << player
            # assign the new player to the sender's ip
            @other_players[sender] = player
        end
    end

    # sends a string to all the out_socks,
    # if the sending fails it drops the sock from the list
    # the string is received by the process_packet method
    def send(str)
        @out_socks = @out_socks.select do |sock|
            error = false
            begin
              sock << str
            rescue
              error = true
            end
            !error
        end
    end

    # returns a string that when sent to another peer will
    # allow them to construct a clone of the local player.
    # TODO: send all players so that multiple people can play from one computer
    def get_player_string
        player = @local_players[0]
        "player<=>" + player.get_string
    end

    # for printing debug messages
    def say(x)
        puts "PEER: " + x
    end
end
